// 배열

// 특정 인덱스 접근 가능 O(1)
// 컴퓨터의 메인 메모리에서 배열의 공간은 연속적으로 할당된다.

// 장점: 캐시 히트 가능성이 높으며 조회가 빠름
// (인접한 공간에 연속적으로 할당되므로 캐시히트 가능성 높음)
// 단점: 일반적으론 배열의 크기를 미리 지정해야 하므로 데이터의 추가 삭제에 한계있음
// (단, JS 에선 동적배열 사용하므로 미리 크기 안정해도 된다.)
// 또한 JS 배열은 배열이나 스택의 기능은 사용가능하지만 큐의 기능은 제공하지 못한다.

// 링크드 리스트
/*
컴퓨터의 메인 메모리상에서 주소가 연속적이지 않다.
배열과 달리 크기가 정해져 있지 않고 리스트의 크기는 동적으로 변경 가능.

장점: 포인터를 통해 다음 데이터의 위치를 가리키므로 삽입,삭제가 간편
단점: 특정 번째의 원소 검색시 앞에서부터 찾아야 하므로 검색 속도 느림

--> 알고리즘 문제 풀이에 큰 영향을 미치지 않으므로 구현할 필요없다.
*/

//배열 만들기
let arr2 = Array.from({ length: 5 }, () => 7); //[7,7,7,7,7]
console.log(arr2);

//4개의 원소를 갖는 Array(4) 배열을 만들건데 각각의 원소또한 5개의 원소를 갖는 배열을 만들거다.
let arr3 = Array.from(Array(4), () => new Array(5)); // 4행 5열 2차원배열 생성
console.log(arr3);

//크기가 N X M 인 2차원 리스트 만들기
let arr4 = new Array(3);
for (let i = 0; i < arr4.length; i++) {
  arr4[i] = Array.from({ length: 4 }, (undefined, j) => i * 4 + j);
}
console.log(arr4);

// 배열 메서드

// concat(): 여러 배열을 이어 붙여 합친 결과 반환 O(n) / 중복가능
let arr5 = [1, 2, 3, 4, 5, 6];
let arr6 = [4, 5, 3];

console.log(arr5.concat(arr6, [11, 12], [15]));

//slice(left,right) : 특정 구간 원소를 꺼낸 배열 반환 (원본유지)
console.log(arr5); // [1,2,3,4,5,6]
console.log(arr5.slice(2, 4)); //[3,4]

// indexOf(): 특정 값을 가지는 원소의 첫째 인덱스 반환 O(n)
console.log(arr5.indexOf(4)); // 3
console.log(arr5.indexOf(9)); // -1 값이 없을때 -1반환
